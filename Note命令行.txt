硬连接和符号链接
	硬链接有两个重要局限性：
		1. 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联与链接本身
		不在同一个磁盘分区上的文件。
		2. 一个硬链接不能关联一个目录。
	    硬连接: ln file1 file2
	符号链接:
	    ln -s file1 file2
	    能够关联目录和文件
	    创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。
	硬连接的符号索引节点相同，符号链接不相同

shell变量:
    撤销变量:unset varname
    本地变量使用local:                  
            如果脚本中存在全局变量var（注意：是脚本范围内的全局变量，不是bash命令行中），同时，脚本中某个函数中如果也有一个变量命名为var并且被赋值，那么函数中的var的值将会覆盖全局变量var的值，如果函数中声明var变量时，使用了local关键字，那么，函数中的local var的值 ，将不会覆盖全局变量var的值，而且在函数中使用的var变量的值仍是local var的值，函数外使用var变量的值仍是全局变量的var的值。
    进程树:pstree
    环境变量:
            使用export关键字指明对应的变量为环境变量，方法如下
			export varname=value
			也可以先声明为本地变量，然后再导出为环境变量,步骤如下
			zsythink="www.zsythink.net"
			export zsythink
	使用source让脚本在当前shell进程中使用，本地变量可以被脚本使用的: source /some/file/ . /some/file
    
    只读变量:
           使用如下方法设置一个只读变量
			readonly rovarname=value
			只读变量设置后不可修改，不可unset（撤销），如果想要只读变量失效需要退出当前shell
			只读变量的只对当前bash生效，"子bash"无法继承当前bash的只读变量，如果想要当前bash的"子bash"或者"孙bash"也能继承当前bash的只读变量，那么需要将只读变量变成环境变量的一种，变成"环境只读变量",使用如下方法，声明一个"环境只读变量"
			export readonly varname=value
			 "环境只读变量"可以被子bash继承到后直接使用
shell算术运算:
    借助let命令进行整数运算：let a = 1+2
                          echo $a
                          "运算过程"与"运算结果"中都不会包含小数
    借助expr命令进行算术运算: 也只能进行整数运算
						    1、数值与运算符号之间需要用空格隔开，否则无法进行算术运算。
							2、使用expr命令进行乘法运算时，需要将"乘号"转义，否则会报错。
    借助bc命令进行算术运算：echo "$a+$b" | bc
                         bc <<< "$a+$b"
                         echo "scale; 8/3" | bc   在使用"除法"时，需要指定小数点精度，否则运算结果中不会包含小数，使用scale指定小数点精度
    使用运算语法 $[算术表达式]: d=$[1+2]
    使用运算语法 $((算术表达式)): d=$((1+2))
    将变量声明为整形: declare -i s 声明变量s为int
shell中的逻辑运算、短路与、短路或:
    在shell中，"与"的运算符为"-a"，同时，"与"的逻辑运算符也可以用"&&"表示。
              if [ 10 -gt 5 -a 9 -gt 3 ];then echo "true"; fi
              if [[ 10 -gt 5 && 9 -gt 3 ]];then echo "true"; fi
           或 if [10 -gt 5] && [9 -gt 3];then echo "true"; fi
    在shell中，"或"的运算符为"-o"，同时，"或"的逻辑运算符也可以用"||"表示。
              if [ 10 -gt 5 -o 9 -gt 3 ];then echo "true"; fi
              if [[ 10 -gt 5 || 9 -gt 3 ]];then echo "true"; fi
           或 if [10 -gt 5] || [9 -gt 3];then echo "true"; fi

    "&&"的短路功能:
              cmd1 && cmd2  表示cmd1执行成功后再执行cmd2，如果cmd1执行失败不再继续
    "||"短路或功能:
              cmd1 || cmd2  表示cmd1执行成功cmd2不再执行，cmd1执行失败则执行cmd2
              cmd1 && cmd2 || cmd 表示如果cmd1执行成功，则执行cmd2，如果cmd1执行失败，则不执行cmd2，而是执行cmd3。  

shell中组合命令的方法:
    (ls go/; ls beego/) | wc -l     在子进程中运行
    { ls go/; ls beego/; } | wc -l        在当前shell中运行

shell中’-gt’与’>’的区别:
    [ $a -gt $b ]  或者  [[ $a -gt $b ]]  
        两个变量的值均为数字，所以我们可以使用关系运算符"-gt"或者"-lt"(小于号)比较两个数字的大小。
    [[ "a" > "b" ]] 或者 [ "a" \> "b" ]
        在shell中，"-gt"或者"-lt"只能用于比较两个数字的大小，当我们想要比较两个字符的ASCII值时，则必须使用">"或者"<"，而且需要注意，当使用"双中括号"进行判断时，">"或者"<"不用转义即可正常使用，当使用"单中括号"进行判断时，">"或者"<"需要转义后才能正常使用。
    [[ 20200804 > 20200803 ]] 或者 [[ "2020-08-04" > "2020-08-03"]]
        如果我们想要比较两个日期的前后，我们可以将日期的格式转化为纯数字的格式，然后进行比较，数字较大的对应的日期应该较晚
        可以直接对比相同字符串格式的日期，日期较晚的字符串转换成ASCII以后，ASCII值应该更大
