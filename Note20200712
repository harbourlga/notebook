
############
Tips: 在mac os上查看你的硬件cpu core数量和硬件线程总数量：
$sysctl -n machdep.cpu.core_count
$sysctl -n machdep.cpu.thread_count
############

############
查看Go程序的汇编代码有许多种方法：

使用objdump工具：objdump -S go-binary
使用gdb disassemble
构建go程序同时生成汇编代码文件：go build -gcflags ‘-S’ xx.go > xx.s 2>&1
将Go代码编译成汇编代码：go tool compile -S xx.go > xx.s
使用go tool工具反编译Go程序：go tool objdump -S go-binary > xx.s
我们这里使用最后一种方法：利用go tool objdump反编译(并结合其他输出的汇编形式)：
###########

20200712
K8S认证与调度

ldd 这个命令可以知道你的一个可执行文件所使用了动态链接库 如：ldd app
Api Server：
    1⃣️Api Server是k8s的入口，是一个典型的web服务器程序，通过对外暴露http(s)接口来提供服务
    2⃣️使用基于ca签名的双向数字证书认证来保证cilent与apiserver之间的安全通行（搞懂是如何进行认证，有多少种认证方式）


###########20200810
docker run --name grpc-test -d -it -v ~/grpc-master:/grpc-master docker.io/grpc/python   挂载grpc

grpc原理: 使用grpc要先写好pb代码,然后用protoc生成代码，生成的代码统称为stub

文章的框架模版: 简介（架构介绍）、特点（特别的地方）、功能（能做什么）、应用（在实际场景中用到了什么地方）、原理（架构或工具底层是怎么实现的）、其他自由发挥如通信方式网络等

python起service
docker run --name grpc-t -d -it -v ~/grpc-master:/grpc-master docker.io/python


###########20200813
优雅的重启web服务，采用热发布和热更新的方法：
     1⃣️思路：借鉴将故障节点从负载均衡的可用节点列表动态剔除的方法，如"nginx -s reload"在不停止服务的情况下重新加载配置文件的内容
             一边将旧版本代码例子下线，一边上线新版本例子代码
     2⃣️注意点：考虑新旧版本的兼容问题，如新版本对数据库增加了字段，旧版本的sql会查多出了个字段。如果旧版本写的不够严谨（如采用数组的形式按序号取字段肯定出问题，可以考虑数据结构设计的时候采用字典的方式）          这个多出来的字段可能会出现问题。
              当把一个服务节点从架构中踢掉以后不能马上将该节点停掉，此时可能有外部请求落在该节点，正确做法是等待一个超时时间之后再停掉
     3⃣️实际场景：可通过服务发现工具(consul,etcd,zookeeper),进程管理工具(nodejs的PM2集群模式),容器编排工具kubernetes提供的rolling-update等实现。

后台任务的平滑停止：1⃣️不考虑：类似kill -9 <process id> 直接暴力杀掉进程的质量
                 2⃣️正确做法：程序在逻辑中需要自己去接收来自用户（停止脚本）的SIGINT or SIGTERM(nginx使用SIGQUIT信号)，在监听到该信号后完成手头任务之后推出
                 3⃣️注意事项：停止脚本的思路大致为先查询对应要停止的进程ID然后使用kill -2 <process id>指令
                            停止脚本在查询id的过程中需要注意的是不应该通过ps aux用字符串匹配的方式去截取id。最好的方式是nginx一样将进程id写如log文件夹下的nginx.pid文件中，需要平滑停止的时候直接拿来用就好了。

单点web服务的原地热启动：1⃣️借鉴golang的开源工具grace:https://github.com/facebookgo/grace
                      2⃣️整体思路：1、最开始只有父进程在运行，当更新了代码要重启时，向父进程发送一个SIGUSR2信号（SIGUSR2常被用于平滑重启）
                                 2、父进程在收到平滑重启,fork出一个子进程并且将自己的所有环境变量，所有socket句柄传递给子进程，而子进程执行我们更新过后的新版代码
                                 3、子进程通过判断PPID(parent process id)是不是init进程来获知自己是否为被fork出来的子进程，也可以由父进程给子进程传额外的环境变量，子进程通过判断该环境变量来判断自己是否是被fork出来的子进程。
                                 4、子进程收到父进程的socket fd，开始构建新的监听服务，即可开始对外提供服务。同时，子进程向父进程发送一个SIGINT信号使其平滑退出。
                                 5、父进程退出后，子进程变孤儿进程，被pid1领养。
                      3⃣️注意事项：1、代码比较麻烦。
                                 2、逻辑有很多需要注意的地方如pid文件的更新时机、环境变量和socket fd的传递

###########20200826
http协议：1⃣️全称：Hyper Text Transfer Protocol（超文本传输协议）
         2⃣️HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。
         3⃣️http基于tcp协议，https基于TLS或SSL协议层之上；http端口号为80，https端口号为443
         4⃣️http的响应方式：响应方式单一，遵循client------->server 单一的方向进行请求，server------->client返回请求
         5⃣️https:全称Hypertext Transfer Protocol over Secure Socket Layer。是以安全为目标的http通道，实现的方式为在http下加入ssl层。端口号443
                 有两种基本的加解密算法类型：
					1）对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
					2）非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。
				流程：
				   --------                        --------
				  | client |                      | server |
                   --------                        --------
                                请求https连接         
                            -------------------->>  
                                返回证书公钥
                            <<-------------------
                   client产生随机的的(对称)密钥
                   client使用公钥对对称密钥加密   

                                发送加密后的对称密钥         
                            -------------------->>
                                
                            <<-------------------
                            
                                通过对称密钥加密密闻通信
                            -------------------->>
                            <<-------------------
         6⃣️Flags值说明：
			    FIN: "finished"简写。表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。
			    SYN: "Synchronisation"简写。表示三次握手建立连接的第一步，在建立连接时发送者发送的第一个包中设置flag值为SYN。
			    RST: "reset"简写。重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者发送包发送到一个不是期望的                  目的主机时，接收端发送reset 重置连接标志的包。
			    PSH: "push"简写。通知接收端处理接收的报文，而不是将报文缓存到buffer中。
			    ACK: "Acknowledgment"简写。表示包已经被成功接收。
			    URG: "urgent"简写。通知接收端处理在处理其他包前优先处理接收到的紧急报文（urgent packets）。详见RFC6093。
			    ECE: "ECN-Echo"简写。ECN表示Explicit Congestion Notification。表示TCP peer有ECN能力。详见RFC3168。
			    CWR: "Congestion Window Reduced"简写。发送者在接收到一个带有ECE flag包时，将会使用CWR flag。 详见RFC3168。
			    NS: "nonce sum"简写。该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。详见 RFC 3540。 
	     7⃣️client和server的交互过程   
				   --------                        --------
				  | client |                      | server |
                   --------                        --------
                                发出连接请求(此为TCP三次握手第一步，此时标志位为SYN，seq:X (x=0))         
                            -------------------->>  
                                server回应了client的请求，并要求确认(此为三次握手的第二步；此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）)
                            <<-------------------  

                                client回应了server的确认(此为三次握手的第三步，为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。)         
                            -------------------->>
                                
                    --------连接成功以下开始传输数据---------
                                 
                           client发送一个页面http请求   [server确认]
                            -------------------->>
                                   发送数据
              [client确认]  <<--------------------
                           client发送一个图片http请求   [server确认]
                            -------------------->>
                                  发送图片数据
               [client确认] <<--------------------    


###########20200831
两种方法查看端口号，并kill掉相关进程
  1⃣️查看占用端口进程的PID：
               lsof -i:{端口号} 或 netstat -tunlp|grep {port}
  2⃣️根据PID kill掉相关进程：
               kill -9 {PID}
               尽量推荐 kill -2 {PID}优雅的退出相关进程



###########20200903
NAT,中文名称：网络地址转换协议；本地机器内部的网络集群都分配有一个本地ip，为了和外部进行通信，需要在本地机器上装有NAT软件的路由器(NAT路由器)
    NAT实现的三种方式：1⃣️静态转换Static Nat:内部和外部网络的ip地址转换是一对一映射的，可以实现外部网络对内部网络特定的（如服务器）的设备进行访问
                     2⃣️动态转换Daynamic Nat:内部网络的ip地址转换为外部网络的ip地址是不固定的，当ISP提供的ip地址少于机器数量时，内部网络随机映射至一个外部网络ip地址
                     3⃣️端口多路复用Port address Translation:只改变出包源端口并对端口进行转换。从而内部网络所有的主机（虚拟机）等都可以共用一个外部网络（IP）。目前网络中应用最多的就是端口多路复用方式。
                     
docker run --privileged=true -p 6379:6379 -v /data/redis/data:/data -v /data/redis/conf/redis.conf:/etc/redis/redis.conf  --name myredis --restart=always -d redis redis-server /etc/redis/redis.conf



###########20200925
redis
1⃣️单指令操作与多指令操作：set/mset; get/mget
                      单指令操作对于多次重复传输相对于多指令消耗更多的传输时间
                      多指令操作在单线程的情况下一次传输大量的数据在redis服务端会等待更长的时间
2⃣️数值的增删查减：可以帮助解决分表操作问题（使用多张表存储同类型数据，但对应的主键id必须保证统一性不能重复）
                string在redis内部存储默认是一个字符串，当遇到incr或decr时会转成数值型进行计算（如果不能转成数值，或超过了redis的数值边界会报错）
3⃣️设置数据有效的生命周期：setex或psetex;可以通过控制数据的生命周期，来控制具有时效性的用户行为
4⃣️hash类型下的key对应的value只能存储string不能再进行嵌套
5⃣️set类型可以实现随机推荐、冷启动（srandmember)
  set可以尝试用来做鉴权
  set可以对网站访问量进行统计，记录不同的cookie或ip

6⃣️redis的持久化：两种方案：
                    第一：数据快照存储，将当前的数据状态进行保存，重点关注在数据(rdb)
                    第二：以日志的形式进行过程存储,存的是操作过程（aof)
7⃣️redis的性能：设计模式基于内存(数据结构基本采用hash查找,读取速度快),采用单线程(避免上下文切换和竞争带来的消耗)
              通过多进程可以充分利用多核优势：单机多开几个redis实例；多机分布式改造。redis是k-v数据库，不是关系数据库，数据之间没有约束，只要client分清哪些key放在那个redis进程上就可以了
              高吞吐量：第一：采用多路(多个socket连接)复用(复用同一个线程)技术，让单个线程高效的处理多个连接请求
                       第二：redis在内存中操作速度快，不会影响性能瓶颈
8⃣️redis的事务：
              什么是事务？  事务防止在操作过程中，指令被插队、打乱等。类似mutex作用，保证事务内队列操作的原子性
              事务的使用方式 multi(事务开始)  ---》 [队列中塞入各种操作] ---》 exec（事务结束，开始执行对列中的各种操作)
                           discard（抛弃事务）
              事务的异常情况：第一种：队列中有一条语法错误，则整个队列销毁
                            第二种：队列中所有的语法都正确，则执行错误的不执行，执行正常的继续运行
              异常情况下事务如何回滚：1⃣️记录操作过程中被影响的数据之前的状态 2⃣️设置指令恢复所有的数据
              事务的锁：应用业务场景：监控数据变没变，没变化则执行事务，变化了则不执行事务； 
                       使用方式：watch 需要在multi事务开始前就指定key。  unwatch取消锁
              事务的分布式锁：应用业务场景：只能让一个客户端占据锁后，执行操作。
                            使用方式：setnx key value
                            死锁的解决方式: 设置锁的超时时间 expire key second ; pexpire key millisecond



##########20200927
golang的sync包


##########20201009
python： Queue包：
             put() 将data塞进队列，每塞一次计数器unfinished_tasks加1
             get() 获取队列数据
             task_done() cosume当前获取队列已经完成，让计数器unfinished_tasks加1
             join() 配合task_done(),阻塞止unfinished_tasks变为0时




