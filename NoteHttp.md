
############
Tips: 在mac os上查看你的硬件cpu core数量和硬件线程总数量：
$sysctl -n machdep.cpu.core_count
$sysctl -n machdep.cpu.thread_count
############

############
查看Go程序的汇编代码有许多种方法：

使用objdump工具：objdump -S go-binary
使用gdb disassemble
构建go程序同时生成汇编代码文件：go build -gcflags ‘-S’ xx.go > xx.s 2>&1
将Go代码编译成汇编代码：go tool compile -S xx.go > xx.s
使用go tool工具反编译Go程序：go tool objdump -S go-binary > xx.s
我们这里使用最后一种方法：利用go tool objdump反编译(并结合其他输出的汇编形式)：
###########

20200712
K8S认证与调度

ldd 这个命令可以知道你的一个可执行文件所使用了动态链接库 如：ldd app
Api Server：
    1⃣️Api Server是k8s的入口，是一个典型的web服务器程序，通过对外暴露http(s)接口来提供服务
    2⃣️使用基于ca签名的双向数字证书认证来保证cilent与apiserver之间的安全通行（搞懂是如何进行认证，有多少种认证方式）


###########20200810
docker run --name grpc-test -d -it -v root/grpc-master:/grpc-master docker.io/grpc/python   挂载grpc

grpc原理: 使用grpc要先写好pb代码,然后用protoc生成代码，生成的代码统称为stub

文章的框架模版: 简介（架构介绍）、特点（特别的地方）、功能（能做什么）、应用（在实际场景中用到了什么地方）、原理（架构或工具底层是怎么实现的）、其他自由发挥如通信方式网络等

python起service
docker run --name grpc-t -d -it -v root/grpc-master:/grpc-master docker.io/python


###########20200813
优雅的重启web服务，采用热发布和热更新的方法：
     1⃣️思路：借鉴将故障节点从负载均衡的可用节点列表动态剔除的方法，如"nginx -s reload"在不停止服务的情况下重新加载配置文件的内容
             一边将旧版本代码例子下线，一边上线新版本例子代码
             master新fork出一些worker子进程，新的worker起好后发送QUIT信号给旧的worker，如果旧的worker请求卡住了导致无法退出可以在配置里提前设置worker_shutdown_timeout等一定时间后让其自行退出。

     2⃣️注意点：考虑新旧版本的兼容问题，如新版本对数据库增加了字段，旧版本的sql会查多出了个字段。如果旧版本写的不够严谨（如采用数组的形式按序号取字段肯定出问题，可以考虑数据结构设计的时候采用字典的方式）          这个多出来的字段可能会出现问题。
              当把一个服务节点从架构中踢掉以后不能马上将该节点停掉，此时可能有外部请求落在该节点，正确做法是等待一个超时时间之后再停掉
     3⃣️实际场景：可通过服务发现工具(consul,etcd,zookeeper),进程管理工具(nodejs的PM2集群模式),容器编排工具kubernetes提供的rolling-update等实现。

后台任务的平滑停止：1⃣️不考虑：类似kill -9 <process id> 直接暴力杀掉进程的质量
                 2⃣️正确做法：程序在逻辑中需要自己去接收来自用户（停止脚本）的SIGINT or SIGTERM(nginx使用SIGQUIT信号)，在监听到该信号后完成手头任务之后推出
                 3⃣️注意事项：停止脚本的思路大致为先查询对应要停止的进程ID然后使用kill -2 <process id>指令
                            停止脚本在查询id的过程中需要注意的是不应该通过ps aux用字符串匹配的方式去截取id。最好的方式是nginx一样将进程id写如log文件夹下的nginx.pid文件中，需要平滑停止的时候直接拿来用就好了。

单点web服务的原地热启动：1⃣️借鉴golang的开源工具grace:https://github.com/facebookgo/grace
                      2⃣️整体思路：1、最开始只有父进程在运行，当更新了代码要重启时，向父进程发送一个SIGUSR2信号（SIGUSR2常被用于平滑重启）
                                 2、父进程在收到平滑重启,fork出一个子进程并且将自己的所有环境变量，所有socket句柄传递给子进程，而子进程执行我们更新过后的新版代码
                                 3、子进程通过判断PPID(parent process id)是不是init进程来获知自己是否为被fork出来的子进程，也可以由父进程给子进程传额外的环境变量，子进程通过判断该环境变量来判断自己是否是被fork出来的子进程。
                                 4、子进程收到父进程的socket fd，开始构建新的监听服务，即可开始对外提供服务。同时，子进程向父进程发送一个SIGINT信号使其平滑退出。
                                 5、父进程退出后，子进程变孤儿进程，被pid1领养。
                      3⃣️注意事项：1、代码比较麻烦。
                                 2、逻辑有很多需要注意的地方如pid文件的更新时机、环境变量和socket fd的传递

###########20200826
http协议：1⃣️全称：Hyper Text Transfer Protocol（超文本传输协议）
         2⃣️HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。
         3⃣️http基于tcp协议，https基于TLS或SSL协议层之上；http端口号为80，https端口号为443
         4⃣️http的响应方式：响应方式单一，遵循client------->server 单一的方向进行请求，server------->client返回请求
         5⃣️https:全称Hypertext Transfer Protocol over Secure Socket Layer。是以安全为目标的http通道，实现的方式为在http下加入ssl层。端口号443
                 有两种基本的加解密算法类型：
					1）对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
					2）非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。
				流程：
				   --------                        --------
				  | client |                      | server |
                   --------                        --------
                                请求https连接         
                            -------------------->>  
                                返回证书公钥
                            <<-------------------
                   client产生随机的的(对称)密钥
                   client使用公钥对对称密钥加密   

                                发送加密后的对称密钥         
                            -------------------->>
                                
                            <<-------------------
                            
                                通过对称密钥加密密闻通信
                            -------------------->>
                            <<-------------------
         6⃣️Flags值说明：
			    FIN: "finished"简写。表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。
			    SYN: "Synchronisation"简写。表示三次握手建立连接的第一步，在建立连接时发送者发送的第一个包中设置flag值为SYN。
			    RST: "reset"简写。重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者发送包发送到一个不是期望的                  目的主机时，接收端发送reset 重置连接标志的包。
			    PSH: "push"简写。通知接收端处理接收的报文，而不是将报文缓存到buffer中。
			    ACK: "Acknowledgment"简写。表示包已经被成功接收。
			    URG: "urgent"简写。通知接收端处理在处理其他包前优先处理接收到的紧急报文（urgent packets）。详见RFC6093。
			    ECE: "ECN-Echo"简写。ECN表示Explicit Congestion Notification。表示TCP peer有ECN能力。详见RFC3168。
			    CWR: "Congestion Window Reduced"简写。发送者在接收到一个带有ECE flag包时，将会使用CWR flag。 详见RFC3168。
			    NS: "nonce sum"简写。该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。详见 RFC 3540。 
	     7⃣️client和server的交互过程   
				   --------                        --------
				  | client |                      | server |
                   --------                        --------
                                发出连接请求(此为TCP三次握手第一步，此时标志位为SYN，seq:X (x=0))         
                            -------------------->>  
                                server回应了client的请求，并要求确认(此为三次握手的第二步；此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）)
                            <<-------------------  

                                client回应了server的确认(此为三次握手的第三步，为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。)         
                            -------------------->>
                                
                    --------连接成功以下开始传输数据---------
                                 
                           client发送一个页面http请求   [server确认]
                            -------------------->>
                                   发送数据
              [client确认]  <<--------------------
                           client发送一个图片http请求   [server确认]
                            -------------------->>
                                  发送图片数据
               [client确认] <<--------------------    

        8⃣️http报文
              一个完整的http报文有起始行、头部、空行、实体组成。请求报文和响应报文只有其实行字段不太一样，其他组成都差不多
              结构如下：   
                           ----------起始行----------
                           ----------头部------------由很多行组成
                           ----------空行------------CRLF
                           ----------实体------------post、put等方法需要提交一些数据到服务端

              起始行：有两种，一种是请求报文的请求行，另一种是响应报文的响应行。
                     请求行：1.请求方法： 是一个动词，如get/post,表示对资源的操作
                            2.请求目标：通常是一个url，标记了请求方法要操作的资源。
                            3.版本号：表示报文使用的http协议版本。
                            这三个部分用空格隔开，最后用crlf来换行

                     响应行：1.版本号：同上
                            2.状态码：一个三位数，用代码的形式表示处理的结果，比如200是成功，500是服务器错误
                            3.原因：作为数字状态码的补充，是更详细的解释文字，帮助理解原因
                            格式同上

      9⃣️请求方法
             背景：http协议最终的目的是为了操作url定位的服务器资源，因此在协议里面必须有某种“动作的指示”，告诉操作这些资源的方式。
             方法：1.get：获取资源，可以理解为读取或者下载数据
                  2.head：类似get，但只获取资源的元信息
                  3.post：向资源提交数据，相当于写入或上传数据
                  4.put：类似post
                  5.delete：删除资源
                  6.connect：建立特殊的连接隧道
                  7.options：列出可对资源实行的方法
                  8.trace：追踪请求-响应的传输路径
             扩展方法：http协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。
             安全与幂等：
                  get和head方法只读操作所以是安全的，其他方法都涉及到服务器的增删改，所以是“不安全的”
                  幂等：多次执行相同的操作，结果都是相同的。post是"新增或提交数据"，多次提交数据会创建多个资源，所以不是幂等的。put是"替换或更新数据"，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。

      🔟body实体
             1. 数据类型与编码
                    假如http没有告知数据类型的功能，服务器把“一大坨”数据发给浏览器，浏览器看到的将是一个黑盒子。因此需要注明数据的类型
                    常见的类型有： a. text文本格式
                                 b. image
                                 c. audio/video
                                 d. application 数据格式不固定可能是文本也可能是二进制，必须由上层应用程序来解释
                    还需要告诉数据是什么编码格式，方便对方解压：a. gzip
                                                          b. deflate
                                                          c. br 新优化的算法

                数据类型使用的头字段：
                      客户端用Accept头告诉服务器希望接收什么样的数据，而服务器用Content头告诉客户端实际发送了什么样的数据。
                      对于编码字段，是可以省略的。如果没有Accept-Encoding字段，就表示不支持接收压缩数据；如果没有Content-Encoding字段，就表示发送数据没有被压缩。

             2.语言类型与编码
                    通过区分语言类型来使浏览器显示不同的语言。

http协议进阶：
       1⃣️http是如何传输大文件的？
               1. 数据压缩 
                     浏览器向服务器发送请求的时候通常都会通过““Accept-Encoding””字段告知自己支持那种压缩格式，例如gzip、deflate、br等。服务器会选择一种压缩算法，放进Content-Encoding响应头里面再把原数据发回给浏览器
                     该方法通常只针对文本数据，对于图片视频等没什么作用

               2.分块传输
                     响应报文：Transfer-Encoding: chunked来表示报文里的body部分不是一次性发过来的，而是分成了许多的块逐个发送。这个参数跟Content-Length是互斥的
                     流式传输：例如由数据库动态生成的表单页面，这种情况下body数据的长度是未知的，无法在头字段"Content-Length"里给出确切的长度，所以必须用分块传输
                     分块传输的编码规则：包含两个部分长度头和数据块
                                       
<div align=center>
<img src="https://static001.geekbang.org/resource/image/25/10/25e7b09cf8cb4eaebba42b4598192410.png"/>
</div>
               3.范围请求




###########20200831
两种方法查看端口号，并kill掉相关进程
  1⃣️查看占用端口进程的PID：
               lsof -i:{端口号} 或 netstat -tunlp|grep {port}
  2⃣️根据PID kill掉相关进程：
               kill -9 {PID}
               尽量推荐 kill -2 {PID}优雅的退出相关进程



###########20200903
NAT,中文名称：网络地址转换协议；本地机器内部的网络集群都分配有一个本地ip，为了和外部进行通信，需要在本地机器上装有NAT软件的路由器(NAT路由器)
    NAT实现的三种方式：1⃣️静态转换Static Nat:内部和外部网络的ip地址转换是一对一映射的，可以实现外部网络对内部网络特定的（如服务器）的设备进行访问
                     2⃣️动态转换Daynamic Nat:内部网络的ip地址转换为外部网络的ip地址是不固定的，当ISP提供的ip地址少于机器数量时，内部网络随机映射至一个外部网络ip地址
                     3⃣️端口多路复用Port address Translation:只改变出包源端口并对端口进行转换。从而内部网络所有的主机（虚拟机）等都可以共用一个外部网络（IP）。目前网络中应用最多的就是端口多路复用方式。
                     
docker run --privileged=true -p 6379:6379 -v /data/redis/data:/data -v /data/redis/conf/redis.conf:/etc/redis/redis.conf  --name myredis --restart=always -d redis redis-server /etc/redis/redis.conf



###########20200925
redis
1⃣️单指令操作与多指令操作：set/mset; get/mget
                      单指令操作对于多次重复传输相对于多指令消耗更多的传输时间
                      多指令操作在单线程的情况下一次传输大量的数据在redis服务端会等待更长的时间
2⃣️数值的增删查减：可以帮助解决分表操作问题（使用多张表存储同类型数据，但对应的主键id必须保证统一性不能重复）
                string在redis内部存储默认是一个字符串，当遇到incr或decr时会转成数值型进行计算（如果不能转成数值，或超过了redis的数值边界会报错）
3⃣️设置数据有效的生命周期：setex或psetex;可以通过控制数据的生命周期，来控制具有时效性的用户行为
4⃣️hash类型下的key对应的value只能存储string不能再进行嵌套
5⃣️set类型可以实现随机推荐、冷启动（srandmember)
  set可以尝试用来做鉴权
  set可以对网站访问量进行统计，记录不同的cookie或ip

6⃣️redis的持久化：两种方案：
                    第一：数据快照存储，将当前的数据状态进行保存，重点关注在数据(rdb)
                    第二：以日志的形式进行过程存储,存的是操作过程（aof)
7⃣️redis的性能：设计模式基于内存(数据结构基本采用hash查找,读取速度快),采用单线程(避免上下文切换和竞争带来的消耗)
              通过多进程可以充分利用多核优势：单机多开几个redis实例；多机分布式改造。redis是k-v数据库，不是关系数据库，数据之间没有约束，只要client分清哪些key放在那个redis进程上就可以了
              高吞吐量：第一：采用多路(多个socket连接)复用(复用同一个线程)技术，让单个线程高效的处理多个连接请求
                       第二：redis在内存中操作速度快，不会影响性能瓶颈
8⃣️redis的事务：
              什么是事务？  事务防止在操作过程中，指令被插队、打乱等。类似mutex作用，保证事务内队列操作的原子性
              事务的使用方式 multi(事务开始)  ---》 [队列中塞入各种操作] ---》 exec（事务结束，开始执行对列中的各种操作)
                           discard（抛弃事务）
              事务的异常情况：第一种：队列中有一条语法错误，则整个队列销毁
                            第二种：队列中所有的语法都正确，则执行错误的不执行，执行正常的继续运行
              异常情况下事务如何回滚：1⃣️记录操作过程中被影响的数据之前的状态 2⃣️设置指令恢复所有的数据
              事务的锁：应用业务场景：监控数据变没变，没变化则执行事务，变化了则不执行事务； 
                       使用方式：watch 需要在multi事务开始前就指定key。  unwatch取消锁
              事务的分布式锁：应用业务场景：只能让一个客户端占据锁后，执行操作。
                            使用方式：setnx key value
                            死锁的解决方式: 设置锁的超时时间 expire key second ; pexpire key millisecond



##########20200927
golang的sync包


##########20201009
python： Queue包：
             put() 将data塞进队列，每塞一次计数器unfinished_tasks加1
             get() 获取队列数据
             task_done() cosume当前获取队列已经完成，让计数器unfinished_tasks加1
             join() 配合task_done(),阻塞止unfinished_tasks变为0时

##########20210105
一台Linux服务器最多能支撑多少个TCP连接？
单个服务ipv4理论上限：2的32次方（ip数）×2的16次方（port数）个连接
单个服务实际上限：跟linux文件数相关，进程每打开一个文件（linux下一切皆文件，包括socket），都会消耗一定的内存资源。
               如果有不怀好心的人启动一个进程来无限的创建和打开新的文件，会让服务器崩溃。所以linux系统出于安全角度的考虑，在多个位置都限制了可打开的文件描述符的数量，包括系统级、用户级、进程级。这三个限制的含义和修改方式如下：
                                  系统级：当前系统可打开的最大数量，通过fs.file-max参数可修改
                                  用户级：指定用户可打开的最大数量，修改/etc/security/limits.conf
                                  进程级：单个进程可打开的最大数量，通过fs.nr_open参数可修改

##########20210106
etcd的注册服务发现：
           1⃣️etcd服务的地址通常不变
           2⃣️key为服务名，value为服务的ip和端口。将kv加入etcd中，后续服务变更了ip地址，客户端只需要填写服务名并保持不变即可随时找到服务。
           3⃣️采用租约定时刷新的形式可以帮助服务在挂了之后在etcd中清除key

ETCD的租约：etcd的租期是定义一个租期id，然后时间就开始流失，你可以将这个租期关联到任何一个key上，租期id的时间到了，关联的所有的key就会被删除
           在租约过期之前可以刷新，一旦过期key给删除之后就不能再续约了
           租约的定时刷新通常新建一个线程或协程死循环，不断的提交更新命令


##########20210118
golang的init：1⃣️init函数先于main函数执行，实现包级别的一些初始化操作。
              2⃣️主要特点：不能被其他函数调用；没有输入参数，返回值；每个包可以有多个init函数；
              3⃣️执行顺序：同个包的init执行顺序不定；不同包的执行顺序根据依赖先后顺序来执行

golang的省略号： 1⃣️使用在数组中：[...]int{1,2,3}；此时数组的长度由初始化数组的元素个数决定
                2⃣️打散切片：arr1 = append(arr1,arr2...)；将一个切片添加到另一个切片内的时候需要加上省略号将切片打散成一个个元素
                3⃣️变长的函数参数：golang的语法糖，参数列表最后的类型名称之前使用省略号“...”表示声明一个变成函数，调用这个函数的时候可以传递该类型任意数目的参数；
                                只能作为函数的最后一个参数出现；尽管...type参数就像函数体内的slice，但变长函数的类型和带有普通slice参数的函数类型不相同
                                实际使用中常常结合2⃣️一起用，在函数外部定义一个切片，函数内部通过省略号使得传入的打散切片仍然为一个完整切片，但跟普通的slice的函数类型有所不同。
                                结合interface特殊的使用：
                                                      func f1(a ...interface{}){
                                                          fmt.Printf("f1 %v\n",a)
                                                      }
                                                      func main() {
                                                          arr := []int{1,2,3}
                                                          arr2 := []int{11,22,33}
                                                          f1(arr,arr2,111,222,333)
                                                      }
                                                      传入的参数作为一个完整的数组成员

##########20210120
golang的select: 1⃣️一个select语句用来选择一个case，case完成发送或接收操作之后立即执行相应的动作。类似于switch，但是它的case相关的是channel有关的I/O操作。
                2⃣️进入一个case之后就不会再跳到别的case上去。
                3⃣️select可能存在着阻塞：如果有一个或多个case的io操作可以同时完成时，程序会随机选择一个进入执行动作。如果没有io操作，但存在着default,则程序进入default里的动作，否则会一直阻塞直到io操作出现(当所有channel陷入沉睡的时候，golang会在此处报死锁错误然后退出)
                4⃣️所有case操作的channel表达式都会被求值，求值顺序从左往右、从上往下。如果是函数返回值在chan上返回，所有case操作完成之后才会去
                5⃣️注意事项：A:尽量不要在chan的io操作返回上面耗时过长
                           B:select中出现case顺序敏感的时候，尽量不要使用函数返回。


##########20210123
go的局部变量分配在堆还是栈：
                1⃣️：在c/c++局部变量逃逸出会产生错误
                2⃣️golang的编译器根据一个局部变量是否会逃逸，会将其分配到堆或栈。不会逃逸的局部变量会将其分配到栈上，逃逸的局部变量会将其分配至堆。
                3⃣️无论是否是new动态分配内存出来的局部变量，golang根据是否会逃匿从而分配到堆或栈上的行为都不会变。 

##########20210130
go调度器设计原理：
           1⃣️进化历程：a:单线程。第一版本就包含了g和m两个结构，但只有一个线程，多个goroutine需要抢夺这一个线程。
                      b:多线程。该版本实现了从不可用到可用的跨越，缺点是抢锁的资源浪费严重。全局锁的问题和linux操作系统调度器在早期遇到的问题比较相似。
                      c:任务窃取调度器。在G-M模型的基础下增加一处理器P，通过P实现g和m之间的调度。基于任务窃取的 Go 语言调度器使用了沿用至今的 G-M-P 模型
                                     该调度器会做的几件事：等待垃圾回收、从本地或全局队列获取待执行的goroutine、在当前线程 M 上运行 Goroutine
                      d:抢占式调度器。抢占式可以解决两个问题：某些goroutine占用了线程之后不会让出，会造成其他goroutine的饥饿。
                                                         垃圾回收时需要暂停整个程序(STW)，长时间暂停会造成程序无法正常工作。
                                    抢占式调度器经历了从协作式抢占到基于信号的抢占式调度。
                                    基于协作式抢占调度器的工作原理：编译器会在调度函数前插入runtime.morestack。程序在运行时，
                                                                会在垃圾回收暂停程序、系统监控发现goroutine运行时间超过10ms时发出抢占请求StackPreempt。
                                                                当发生函数调用时，runtime.morestack可能会调用runtime.newstack去检查Goroutine的stackguard0字段是否为StackPreempt，
                                                                假如stackguard0是StackPreempt就会触发抢占让出当前线程。
                                    基于信号抢占调度器的工作原理：程序启动时，在 runtime.sighandler 中注册 SIGURG 信号的处理函数 runtime.doSigPreempt；
                                                              在触发垃圾回收的栈扫描时会调用 runtime.suspendG 挂起 Goroutine，该函数会执行下面的逻辑：
                                                                                    将 _Grunning 状态的 Goroutine 标记成可以被抢占，即将 preemptStop 设置成 true；
                                                                                    调用 runtime.preemptM 触发抢占；
                                                              runtime.preemptM 会调用 runtime.signalM 向线程发送信号 SIGURG；
                                                              操作系统会中断正在运行的线程并执行预先注册的信号处理函数 runtime.doSigPreempt；
                                                              runtime.doSigPreempt 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 runtime.sigctxt.pushCall；
                                                              runtime.sigctxt.pushCall 会修改寄存器并在程序回到用户态时执行 runtime.asyncPreempt；
                                                              汇编指令 runtime.asyncPreempt 会调用运行时函数 runtime.asyncPreempt2；
                                                              runtime.asyncPreempt2 会调用 runtime.preemptPark；
                                                              runtime.preemptPark 会修改当前 Goroutine 的状态到 _Gpreempted 并调用 runtime.schedule 让当前函数陷入休眠并让出线程，调度器会选择其它的m Goroutine 继续执行；
           2⃣️调度器数据结构：G: goroutine,Go 语言调度器中待执行的任务。与内核空间线程相比，goroutine占用更小的内存空间，上下文切换开销也更低。
                           M:操作系统线程，根据GOMAXPROCS决定有几个线程，通常默认设置为机器的核数。默认的设置不会频繁触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少很多额外开销。m持有两类goroutine(g0和curg),其中g0是持有调度栈的Goroutine，是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行。curg是在当前线程上运行的用户Goroutine。
                           P:M和G之间的中间层，能够提供线程需要的上下文环境，负责调度线程上的等待队列。通过p的调度，每个内核线程都能够执行多个goroutine,能够在goroutine进行一些IO操作时及时让出计算资源，提高线程的利用率。处理器数量一定会等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上。
           3⃣️调度: a:调度器的启动：主要是根据环境变量GOMAXPROCS启动相应数量的系统线程m和处理器p
                  b: 创建goroutine:  代码里：使用关键字go启动一个新的g。关键字go会经过转换成runtime.newproc去调用。
                                      流程：1.初始化新的goroutine结构体。runtime.newproc1会从处理器或者调度器的缓存中获取新的结构体或者runtime.malg函数创建一个新的goroutine结构体。
                                           2.将goroutine放到运行队列上去，可能是调度器全局的运行队列或者是处理器持有的本地队列。只有在本地队列(最多256个待执行任务)没有剩余空间时才会执行全局队列。
                                           3.调度信息。newg.sched.pc中存储了传入函数的程序计数器；sp中存储了runtime.goexit函数的程序计数器
                  c:调度循环: 解释：goroutine从被调度到清理移除这一过程的不断循环
                             流程：1.调度器启动之后，程序会调用runtime.mstart以及runtime.mstart1，前者会初始化stackguard0和stackguard1字段，后者会会初始化线程并调用 runtime.schedule启动调度循环。
                                  2.runtime.schedule：主要用途是寻找待执行的goroutine。
                                                      会从以下几个方面去寻找：a.通过schedtick保证有一定的几率从全局队列中查找对应的goroutine.
                                                                           b.从处理器p本地的队列中查找待执行的goroutine。
                                                                           c.如果以上两种方法都没有找到会通过runtime.findrunnable阻塞式的等待goroutine。
                                  3.runtime.execute：执行获取到的goroutine并做一系列准备工作。
                                  4.runtime.gogo：将准备好的goroutine调度到线程上去。该函数会从runtime.gobuf中取出runtime.goexit的程序计数器(栈 SP)和待执行函数的程序计数器(寄存器BX)
                                  5.经过一系列复杂的函数调用，我们最终在当前线程的 g0 的栈上调用 runtime.goexit0 函数，该函数会将 Goroutine 转换会 _Gdead 状态、清理其中的字段、移除 Goroutine 和线程的关联并调用 runtime.gfput 重新加入处理器的 Goroutine 空闲列表 gFree。然后goexit0最末尾会重新触发runtime.schedule
                                  6.整个调度循环永远不会返回：runtime.schedule --> runtime.execute --> runtime.gogo --> runtime.goexit

##########20210201
go的runtime机制：
           1⃣️负责范畴：管理任务调度、垃圾回收、运行环境等。runtime和用户编译后的代码被linker静态链接起来，形成了一个可执行文件。
           2⃣️go的可执行文件：从运行的角度来说，整个程序分为代码和runtime。runtime接口函数来调用goroutine，channel及其他的一些高级功能，例如像追踪goroutine的运行和它时如何分配到指定线程上的。

go的监控：
           1⃣️runtime包：获取go程序运行时的协程数量, gc 时间, 对象数, 堆栈等信息。
           2⃣️expvar包：程序注册expvar，可以通过http的方式获取监控变量以及自己自定义的变量。
 
go的调试及性能问题：
           1⃣️panic调用栈：当因为逻辑问题导致后台进程挂掉时，不容易发现程序曾经挂过。golang 可以通过 recover 捕获 error，并将 panic 时的堆栈打印到日志来定位问题。
           2⃣️pprof：可视化的界面，可以进行cpu、内存、阻塞、互斥锁等分析。可以使用火焰图查看压测的情况
                    几个重要的指标：flat：给定函数上运行耗时
                                  flat%：同上的 CPU 运行耗时总比例
                                  sum%：给定函数累积使用 CPU 总比例
                                  cum：当前函数加上它子函数的调用运行总耗时
                                  cum%：同上的 CPU 运行耗时总比例
           3⃣️压测：a.通过go.test进行单元测试和压力测试
                   b.通过第三方工具go-stress-testing
                        git address: https://github.com/link1st/go-stress-testing#41-介绍

go中make和new的区别：
           1⃣️make:用于内建类型(slice、channel、map)的内存分配。make(T, args)，返回的是一个T类型的有初始值的值。
           2⃣️new:用于各种类型的内存分配。new(T)，分配了零值填充的t类型的内存空间，返回的是一个地址即*T。

go中一个局部变量分配：
           1⃣️函数内部的局部变量一般是申请到栈上的，原因是函数返回直接释放，不会引起垃圾回收，对性能没有影响。
           2⃣️局部变量申请到堆上：a.申请到堆上的变量会引起垃圾回收，该过程频率过高会引起gc压力过大，程序性能出现问题。
                              b.局部变量申请的内存过大或者是动态分配不定空间的变量会导致在堆上申请，局部变量需要函数返回也会在堆上申请。
           3⃣️逃逸总结分析：a.栈上分配的内存比在堆上的效率和性能更高
                         b.栈上分配的内存不需要GC处理;堆上分配的内存使用完毕会交给gc处理
                         c.逃逸分析的目的是决定内存地址分配到栈还是堆上
                         d.逃逸分析在编译阶段完成，作为开发者不需要管一个变量最终是分配到堆还是栈上


go中无缓冲的chan的发送和接收是否同步
          1⃣️channel无缓冲时，发送队列阻塞直到数据被接收，接收队列阻塞直到读到数据。
          2⃣️channel有缓冲时，当缓冲满时发送队列阻塞，当缓冲空时接收队列阻塞。

goroutine的并发控制和优雅退出
          1⃣️并发控制：a.通过无缓冲通道channel实现多goroutine的并发控制。当主 goroutine 运行到 <-channel 接受 channel 的值的时候，如果该  channel 中没有数据，就会一直阻塞等待，直到有值。
                     b.通过sync.WaitGroup实现并发控制，它会收集所有的goroutine任务。wg.Add(1)表示增加一个任务，将&wg传入goroutine任务内通过wg.Done()表示该任务完成。
                       当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回
          2⃣️并发的优雅退出: a.使用for...range结构遍历一个channel。当channel被发送数据的协程关闭时，range就会结束**，接着退出for循环。
                            并发中的使用场景是：当协程只从1个channel读取数据，然后进行处理，处理后协程退出。
                          b.使用,ok退出：
                                   利用for-select结构中select多路复用的能力，可处理多个channel在同一个goroutine内。
                                   但select没有感知channel的关闭，需要解决以下两个问题：
                                                      1.继续在关闭的通道上读，会读到通道传输数据类型的零值，如果是指针类型，读到nil，继续处理还会产生nil。(使用,ok来检测通道的关闭,某一channel关闭后如果需要退出goroutine则直接return,如果还需要继续处理其他case则直接将该case的channel置为nil)
                                                      2.继续在关闭的通道上写，将会产生panic（解决方案是通道只由发送方关闭，不在select上写数据进channel）

                          C.使用退出通道退出
                                  ,ok不能适用的两种情况：1.接收goroutine要通知发送goroutine我要提前退出了。
                                                      2.处理数据的接收goroutine需要提前退出。
                                  解决方案：使用一个专门的通道，发送退出的信号，可以解决这类问题。

Golang的interface的特性和技巧
          1⃣️空接口：不包含任何方法但又可以表示任何类型；golang的所有基础类都实现了空接口，可以用[]interface表示结构不同的数组。
          2⃣️接口嵌套接口：一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。
          3⃣️类型断言：使用类型断言来测试在某个时刻接口varI是否包含类型 T 的值（v := varI.(T)）；
                     类型断言可能是无效的,使用switch（判断类型）case（类型结果）来枚举所有可能的类型

golang常见问题整理：
          1⃣️defer执行顺序是先进后出,值传递的顺序还是按照原顺序 。协程遇到panic时，遍历本协程的defer链表，并执行defer。panic如果没遇到recover则最后向stderr抛出panic信息。
          2⃣️使用foreach遍历某一数组、map等数据结构的值一定是拷贝的副本，该副本的地址都是一样的，因此不能直接用for出来的值对应的指针地址。解决方法是不要引用该副本的地址，开辟一块新地址或直接用值。
          3⃣️执行的随机性和闭包：goroutine在处理闭包问题时，应避免闭包内的变量时随机变的。假如碰到在外部随机变化的变量时应进行值拷贝，go func内部指向值拷贝地址。
          4⃣️select随机性的三点原则:select 中只要有一个case能return，则立刻执行。
                                当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。
                                如果没有一个case能return则可以执行”default”块。
          5⃣️make初始化切片并赋予容量，是有默认值根据切片内不同的类型决定
          6⃣️map线程安全：情况a: Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。
                        解决方案：使用sync.Map结构代替原生map，增删查改使用sync.Map结构下的方法，如Store、Delete、Load、Range等。
                        情况b: map在并发写入的情况下，假如没上锁系统会出错。
                        解决方案：如上sync.Map结构代替原生map; 使用读写锁 sync.RWMutex实现 对map的并发访问控制

                        场景：在读多写少的情况下建议使用sync.Map


          7⃣️变量类型断言：switch i.(type) 。。。。。。变量i只有在interface类型下才能使用type
          8⃣️函数返回值命名：在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名。 如果返回值有有多个返回值必须加上括号； 如果只有一个返回值并且有命名也需要加上括号
                          函数返回值名字会在函数起始处被初始化为对应类型的零值并且作用域为整个函数,最后return可以不用再声明。
                          函数内部通过:=创建的新变量与返回值列表内的变量不是同一个，尽管可能名字相同，此时返回的一定是返回值列表内初始化的值，需要在函数内部引用需要使用“=”而不是“:=”
          9⃣️结构体比较：a.结构体只有在顺序、字段内容完全相同且类型不为map、slice才可以比较
                       b.含map、slice类型的结构体用reflect.DeepEqual(A, B)进行比较
          🔟函数返回值类型：nil可以用作 error、interface、function、pointer、map、slice 和 channel 的“空值”。
          1⃣️0⃣️const中的iota:意义：可视作const中的行索引。第一行初始化为0。假如没自定义值，下面行的会自动填充上一行的值。假如某行出现自定义值,下面行会自动填充上面行的值。
               const初始化：常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。即不能通过指针引用地址
          1⃣️1⃣️goto：goto配合条件语句使用，需要自己自定义一个跳转的名字如loop。不能跳转到其他函数或者内层代码。尽量少用
          1⃣️2⃣️type:新类型定义 type newVar int,后续使用需要强转，即声明内容类型与底层变量一摸一样。
                    别名定义 type alias = int, 直接当作int使用，
                    结构体定义：type Person struct {}
                    接口定义：type Personer interface{
                                  ShowName(s string)
                              }
                    函数类型定义：type cb func(s string) 在该定义函数基础上可以赋予方法。
          1⃣️3⃣️struct报ambiguous selector错误：只要结构体内有两个子类型引用的方法、字段重复则会报该错误。无论是type lias还是type defintion
                                              改进：直接显式的引用结构体内部子类型对应的方法或字段
          1⃣️4⃣️闭包延迟求值：闭包内引用的外部函数变量地址是不变的，但该地址存储的内容可能随时会变。例如闭包在for循环复用变量i，变量i的地址是不会变的，导致最后取值大小决定于最后闭包执行的时候。
                          解决方法是在闭包内创建个新变量将外部变量i的内容指向新地址。
          1⃣️5⃣️往已经关闭的channel内写数据是会引起panic,但是可以继续读channel
          1⃣️6⃣️中文字符串的长度：在go中中文字符是用utf-8编码的，在字符串上调用len，计算的是字符串包含byte的个数。每个中文字，占3个byte。
          1⃣️7⃣️map中的结构体:map的值会在内存中移动，并且旧的指针地址在map改变时会变得无效。当value为一个结构体的时候，假如一开始写入map的结构体不是指针，那么该结构体的地址可能随时都在变化。此时go程序     会不允许我们改变该结构体。改进方法是map中引用的值是一个指针地址，那么之后修改的就是该指针地址对应的结构体。
          1⃣️8⃣️interface接纳类型：func f(x interface{})的interface{}可以支持传入golang的任何类型，包括指针类型；
                                func g(x *interface{})只支持*interface{}。
          1⃣️9⃣️匿名函数是不能够自己调用自己去迭代的
          2⃣️0⃣️go文件中初始化顺序规则：引入的包-->当前的包的常量变量-->当前包的init-->main函数
          2⃣️1⃣️json.Marshal:将数据编码成json字符串。
                            要点：a.只要是可导出成员(变量首字母是大写)都可以转成json。首字母是小写的为不可导出成员
                                 b.如果变量打上了json标签，那么转化成json的key就用该标签名。否则取变量名作为key名
                                 c.不能被编码成json字符串的类型:channel、complex、函数、循环的数据结构等。bool可以被编码成json字符串
                                 d.指针变量在编码时自动会转化成它所指向的值。
                                 e.json编码成字符串后就是纯粹的字符串
              json.Unmarshal:将json字符串解码到对应的数据结构上面。
                            要点：a.需要一个“接收体”接收解析后的数据，且Unmarshal接收体必须传递指针。否则数据虽然不会报错但是数据无法传递到接收体中。
                                 b.解析时，“接收体”自行定义，json串会在接收体中寻找匹配的值进行赋值：
                                           该变量必需是可导出的，即首字母大写。
                                           先查找与key一样的json标签，找到则赋值给该标签对应的变量。
                                           没有json标签的，就从上往下依次查找变量名与key一样的变量。变量名忽略大小写后与key一样的变量。第一个匹配的就赋值，后面就算有匹配的也忽略。
                                 c.不可导出的变量无法被解析，即“接收体”中首字母是小写的。当“接收体”中存在json串中匹配不了的项时，解析会自动忽略该项，该项仍保留原值。
                                 



golang常见概念整理：
          1⃣️类型、接口、方法：一个类型可以实现多种方法。一个接口可能定义了一堆方法，这些方法无论是什么类型，只要方法名和接口定义的一致，那么就可以说该接口定义了该方法。总的来说就是接口定义的方法与类型无关。
          2⃣️switch、case、fallthrough：golang在执行完每个case后会跳出switch语句块，即使是空的case。某一case内的fallthrough指示执行下一个case（不论该case的条件是否满足都会执行）,不会跳到下下个。

golang中的socket编程:
         1⃣️数据包加入包的长度：客户端向服务端发送数据包或是单向传输数据之类的，需要把数据包的长度加入包里，假如是短连接，可以让服务端可以判断几时该包收完了从而退出收包的动作。
          

golang第三方库整理：
         1⃣️"github.com/go-redis/redis"  redis客户端操作

         2⃣️"sync" 异步编程同步相关库

         3⃣️"bufio" 
                目的：多次进行小量的写操作会影响程序性能。每一次写操作最终都会体现为系统层调用，频繁进行该操作将有可能对 CPU   造成伤害。而且很多硬件设备更适合处理块对齐的数据，例如硬盘。为了减少进行多次写操作所需的开支，golang 提供了 bufio.Writer。
                     数据将不再直接写入目的地(实现了 io.Writer 接口)，而是先写入缓存，当缓存写满后再统一写入目的地：producer --> buffer --> io.Writer

         4⃣️"net":提供了网络io的便携接口，包括tcp/ip;UDP;域名解析
                  尽管net包提供了大量访问底层的接口，但是大多数情况下，客户端仅仅只需要最基本的接口，例如Dial，LIsten，Accepte以及分配的conn连接和listener接口。 crypto/tls包使用相同的接口以及类似的Dial和Listen函数。

性能优化总结：1⃣️代码优化：有一些性能问题完全是由于代码不合理不一定需要缓存、异步、jvm。如循环过多、条件判断累赘、相同逻辑重复多次

            2⃣️数据库：a.sql调优：用自带的慢查询日志或开源的慢查询日志定位到具体的出问题的sql，然后用explain、profile等工具来逐步调优。

                    b.架构层面的调优：这一类调优包括读写分离、多从库负载均衡、水平和垂直分库分表等方面，一般需要的改动较大，但是频率没有SQL调优高，而且一般需要DBA来配合参与。那么什么时候需要做这些事情？我们可以通过内部监控报警系统（比如Zabbix），定期跟踪一些指标数据是否达到瓶颈，一旦达到瓶颈或者警戒值，就需要考虑这些事情。通常，DBA也会定期监控这些指标值。

                    c.连接池调优:我们的应用为了实现数据库连接的高效获取、对数据库连接的限流等目的，通常会采用连接池类的方案，即每一个应用节点都管理了一个到各个数据库的连接池。随着业务访问量或者数据量的增长，原有的连接池参数可能不能很好地满足需求，这个时候就需要结合当前使用连接池的原理、具体的连接池监控数据和当前的业务量作一个综合的判断，通过反复的几次调试得到最终的调优参数。
            
            3⃣️缓存：a.本地缓存(go-cache)，缓存服务（Redis/Tair/Memcache等）。

                    b.使用场景：什么场景适用缓存？
                               1.短时间内相同数据被重复查询且数据更新不频繁，这个时候可以先从缓存中查询，查询不到再从数据库中加载并写入缓存中。此场景适用于单机缓存
                               2.高并发查询热点数据，后端服务不堪重负，可以通过缓存来缓解压力

                    c.选型考虑：
                      1.如果数据量小，且数据更新或清空不频繁(会导致gc压力即垃圾回收频繁)，可以选择本地缓存。如需一些策略支持可以选这gcache，包含了一些缓存满淘汰的算法。如不需要可以直接使用map构建。
                      2.其他情况考虑缓存服务通常用redis

                    d.设计关键点
                       1.什么时候更新缓存?如何保障更新的可靠性和实时性：
                             *热门的数据实时更新，如一个新病人病历过来，在计算出需要的结果之后实时更新到缓存中去。
                             *给每个数据项设立一个过期时间如5-10分钟这样，过期之后再从db中捞出来经过计算转化再把结果写入缓存中。这个策略是对第一个的有效补充，帮助解决手动更新db、程序出错的情况。
                      2.缓存满了怎么办？
                             *给缓存服务选这合适的逐出算法，如常见的lru
                             *针对当前设置的容量，设置合适的警戒线。比如10g的缓存，当超过8g的时候就开始进行预警，提前排查问题或者扩容。
                             *给一些没有必要不热门的key，设置过期时间。

            4⃣️异步：a.使用场景
                          针对某些客户端的请求，在服务端可能需要针对性的对这些请求做一些事情。这些事情用户可能并不关心并且不需要立即就拿到结果，这种情况比较适合用异步的方式处理这些事情
                    b.作用
                          *不用一直排队阻塞等到前面的请求处理完再返回。可以缩短接口响应时间，使用户的请求快速返回,用户体验更好。
                          *避免io线程长时间处于运行状态。运行时间过长会引起服务线程池的可用线程长时间不够用，进而引起线程池任务长度增大，从而阻塞更多的请求任务。
                          *线程长时间处于运行状态，可能还会引起系统load、cpu使用率、机器整体性能下降等一系列问题，甚至引起雪崩
                    c.常见作法
                          *额外开辟线程：采用额外开辟一个线程或使用线程池，在io线程之外的线程来处理相应的任务(如写db)，然后在io线程中让response先返回
                          *使用消息队列（MQ）中间件服务，MQ天生就是异步的。一些额外的任务可能不需要我这个服务来处理，但是需要其他服务来处理。这个时候可以把该任务封装成一个消息丢到消息队列里面，通过消息队列中间件的可靠性保证把消息传递到它所要去的服务，然后让这个服务来处理。
                             例如：一个请求进来服务a需要做实体名的提取，除了正常返回提取的结果，还需要转发到其他端做一些写库或者计算的任务，那么可以把结果先返回给客户端，返回之前往一个MQ发送一个消息即可。

            5⃣️NoSql: a.与缓存的区别：
                           与缓存可能会有一样的数据存储方案如redis等，但是使用的方法不同，这里是将其作为db来使用，如mongo等。如果当作DB来用，需要有效保证数据存储方案的可用性、可靠性。
                      b.使用场景：
                           如果业务数据不需要和其他数据作关联，不需要事务或外键之类的支持，而且有可能写入会异常频繁，这个时候就比较适合使用nosql（比如hive、hbase）

            6⃣️多线程与分布式
                     a.使用场景：离线任务、耗时任务、异步任务、大数据任务适当运用多线程与分布式可以加速。线上响应时间要求高的，尤其是服务线程需要等待任务线程完成的场合尽量不用多线程。此时如果要使用应该对服务线程设置一个最大等待时间
                     b.常见做法：1.对于单机多线程，可以使用线程池。线程池可以帮助节省线程创建和销毁的开销，并且可以限流让后面进来的任务进入之后，让其在队列中进行排队，保障机器极限压力下的稳定处理能力
                             2.如果单机不能满足性能要求，则需要使用多机多线程的方式（在微服务实际工作中很多都是这样的情况）。
                                 首先就必须引入一个单独的节点，作为调度器，其他的机器节点都作为执行器节点。调度器来负责拆分任务，和分发任务到合适的执行器节点；执行器节点按照多线程的方式（也可能是单线程）来执行任务。这个时候，我们整个任务系统就由单击演变成一个集群的系统，而且不同的机器节点有不同的角色，各司其职，各个节点之间还有交互。这个时候除了有多线程、线程池等机制，像RPC、心跳等网络通信调用的机制也不可少。
            7⃣️度量系统(监控、报警、服务依赖管理)
                     度量系统为性能优化提供了一个强有力的数据参考和支撑。没有度量系统，基本上没有办法定位到系统的问题。
                     a.关键流程：确定指标--》采集数据--〉计算并存储结果--》--〉展示和分析
                     b.需要监控和报警哪些指标数据？需要关注哪些？
                               1.接口性能相关，包括单个接口和全部的qps、响应时间、调用量(统计时间维度越细越好；最好是能以节点为维度同时又能统计集群的维度)其中还涉及到服务依赖关系的管理，这个时候需要用到服务依赖管理系统
                               2.单个节点相关，包括cpu使用率、load值、内存占用率、网卡流量等。如果节点是一些特殊类型的服务（比如MySQL、Redis、Tair），还可以监控这些服务特有的一些关键指标。
                    c.数据采集方式：通常采用异步上报的方式：1.发到本地消息队列中间件服务的端口，数据远程的Hadoop集群或者Storm集群来进行运算；
                                                       2.直接在本地计算好，使用异步和本地队列的方式，发送到监控服务器
                    d.数据计算:可以采用离线运算（MapReduce/Hive）或者实时/准实时运算（Storm/Spark）的方式，运算后的结果存入MySQL或者HBase；某些情况，也可以不计算，直接采集发往监控服务器。
                    e.展现和分析：提供统一的展现分析平台，需要带报表（列表/图表）监控和报警的功能。

            8⃣️服务流量限制：
                    a.漏桶：有一个一直装满了水的桶，每隔固定的一段时间即向外漏一滴水。如果接到了这滴水则可以继续服务请求，如果没有接到，那么就需要等待下一滴水
                    b.令牌桶：匀速向桶中添加令牌，服务请求的时候需要向桶中获取令牌，令牌的数目可以按照需要消耗的资源进行相应的调整。如果没有令牌，可以选择等待或者放弃。令牌桶是允许一定的并发的，如果桶中有100个令牌，那么可以同时支持100请求的并发。

                    两种方法的区别：漏桶流出的速率固定，而令牌桶只要桶中有令牌就可以进行请求。当请求过于密集的时候，产生令牌的速度跟不上请求速度，令牌桶可能就会变成漏桶

                    开源包："github.com/juju/ratelimit"


测试：测试都是根据需求来的，因此确认测试的依据是需求分析报告。
     根据不同的测试阶段，测试可以分为单元测试、集成测试、系统测试和验收测试。体现了测试由小到大、又内至外、循序渐进的测试过程和分而治之的思想。
              单元测试：粒度最小，一般由开发小组采用白盒方式来测试，主要测试单元是否符合“设计”。
              集成测试：界于单元测试和系统测试之间，起到“桥梁作用”，一般由开发小组采用白盒加黑盒的方式来测试，既验证“设计”，又验证“需求”。
              系统测试：粒度最大，一般由独立测试小组采用黑盒方式来测试，主要测试系统是否符合“需求规格说明书”。
              验收测试：与系统测试相似，主要区别是测试人员不同，验收测试由用户执行。
              黑盒测试：不考虑程序内部结构和逻辑结构，主要是用来测试系统的功能是否满足需求规格说明书。一般会有一个输入值，一个输出值，和期望值做比较。
              白盒测试：主要应用在单元测试阶段，主要是对代码级的测试，针对程序内部逻辑结构，测试手段有：语句覆盖、判定覆盖、条件覆盖、路径覆盖、条件组合覆盖
              集成测试：主要用来测试模块与模块之间的接口，同时还要测试一些主要业务功能。
      系统测试是在经过以上各阶段测试确认之后，把系统完整地模拟客户环境来进行的测试








