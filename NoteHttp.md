# http协议  

1⃣️全称：Hyper Text Transfer Protocol（超文本传输协议）

2⃣️HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。

3⃣️http基于tcp协议，https基于TLS或SSL协议层之上；http端口号为80，https端口号为443

4⃣️http的响应方式：响应方式单一，遵循client------->server 单一的方向进行请求，server------->client返回请求

5⃣️https:全称Hypertext Transfer Protocol over Secure Socket Layer。是以安全为目标的http通道，实现的方式为在http下加入ssl层。端口号443

​		 有两种基本的加解密算法类型：

​		1）对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；

​		2）非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。
​				流程：

                      --------                        --------
                     | client |                      | server |
                      --------                        --------
                                  请求https连接         
                              -------------------->>  
                                  返回证书公钥
                              <<-------------------
                            client产生随机的的(对称)密钥
                            client使用公钥对对称密钥加密   
      
                                  发送加密后的对称密钥         
                              -------------------->>
                                  
                              <<-------------------
                              
                                  通过对称密钥加密密闻通信
                              -------------------->>
                              <<------------------- 

6⃣️Flags值说明：

​		 FIN: "finished"简写。表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。

​		SYN: "Synchronisation"简写。表示三次握手建立连接的第一步，在建立连接时发送者发送的第一个包中设置flag值为SYN。

​	    RST: "reset"简写。重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者发送包发送到一个不是期望的                  目的主机时，接收发送reset 重置连接标志的包。

​	    PSH: "push"简写。通知接收端处理接收的报文，而不是将报文缓存到buffer中。

​	    ACK: "Acknowledgment"简写。表示包已经被成功接收。

​	    URG: "urgent"简写。通知接收端处理在处理其他包前优先处理接收到的紧急报文（urgent packets）。详见RFC6093。

​	    ECE: "ECN-Echo"简写。ECN表示Explicit Congestion Notification。表示TCP peer有ECN能力。详见RFC3168。

​	    CWR: "Congestion Window Reduced"简写。发送者在接收到一个带有ECE flag包时，将会使用CWR flag。 详见RFC3168。

​	    NS: "nonce sum"简写。该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。详见 RFC 3540。 

7⃣️client和server的交互过程   

		         --------                        --------
			      | client |                      | server |
	           --------                        --------
	                        发出连接请求(此为TCP三次握手第一步，此时标志位为SYN，seq:X (x=0))         
	                    -------------------->>  
	                        server回应了client的请求，并要求确认(此为三次握手的第二步；此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）)
	                    <<-------------------  
	                        client回应了server的确认(此为三次握手的第三步，为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。)         
	                    -------------------->>
	                        
	            --------连接成功以下开始传输数据---------
	                         
	                   client发送一个页面http请求   [server确认]
	                    -------------------->>
	                           发送数据
	      [client确认]  <<--------------------
	                   client发送一个图片http请求   [server确认]
	                    -------------------->>
	                          发送图片数据
	       [client确认] <<--------------------    

8⃣️http报文

​      一个完整的http报文有起始行、头部、空行、实体组成。请求报文和响应报文只有其实行字段不太一样，其他组成都差不多
​          结构如下：   
​                       ----------起始行----------

​                       ----------头部------------由很多行组成

​                       ----------空行------------CRLF

​                       ----------实体------------post、put等方法需要提交一些数据到服务端

​		起始行：有两种，一种是请求报文的请求行，另一种是响应报文的响应行。

​		              请求行：1.请求方法： 是一个动词，如get/post,表示对资源的操作

​                                      2.请求目标：通常是一个url，标记了请求方法要操作的资源。

​                                      3.版本号：表示报文使用的http协议版本。

​                                      这三个部分用空格隔开，最后用crlf来换行

​                      响应行：1.版本号：同上

​                                      2.状态码：一个三位数，用代码的形式表示处理的结果，比如200是成功，500是服务器错误

​                                      3.原因：作为数字状态码的补充，是更详细的解释文字，帮助理解原因

​                                     格式同上

  9⃣️请求方法

​         背景：http协议最终的目的是为了操作url定位的服务器资源，因此在协议里面必须有某种“动作的指示”，告诉操作这些资源的方式。

​         方法：1.get：获取资源，可以理解为读取或者下载数据

​              2.head：类似get，但只获取资源的元信息

​              3.post：向资源提交数据，相当于写入或上传数据

​              4.put：类似post

​              5.delete：删除资源

​              6.connect：建立特殊的连接隧道

​              7.options：列出可对资源实行的方法

​              8.trace：追踪请求-响应的传输路径

​         扩展方法：http协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。

​         安全与幂等：

​              get和head方法只读操作所以是安全的，其他方法都涉及到服务器的增删改，所以是“不安全的”

​              幂等：多次执行相同的操作，结果都是相同的。post是"新增或提交数据"，多次提交数据会创建多个资源，所以不是幂等的。put是"替换或更新数据"，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。

  🔟body实体

   1. 数据类型与编码

   2. p没有告知数据类型的功能，服务器把“一大坨”数据发给浏览器，浏览器看到的将是一个黑盒子。因此需要注明数据的类型

   3. 常见的类型有：

         ​             a. text文本格式

         ​             b. image

         ​             c. audio/video

         ​             d. application 数据格式不固定可能是文本也可能是二进制，必须由上层应用程序来解释

         还需要告诉数据是什么编码格式，方便对方解压：

         ​                                      a. gzip

         ​                                      b. deflate

         ​                                      c. br 新优化的算法

         数据类型使用的头字段：

         ​      客户端用Accept头告诉服务器希望接收什么样的数据，而服务器用Content头告诉客户端实际发送了什么样的数据。

         ​      对于编码字段，是可以省略的。如果没有Accept-Encoding字段，就表示不支持接收压缩数据；如果没有Content-Encoding字

         段，就表示发送数据没有被压缩。

         ​      2.语言类型与编码

         ​    通过区分语言类型来使浏览器显示不同的语言。

# http协议进阶：

## 1⃣️http是如何传输大文件的？

   1. 数据压缩的时候通常都会通过““Accept-Encoding””字段告知自己支持那种压缩格式，例如gzip、deflate、br等。服务器会选择一

      种压缩算法，放进Content-Encoding响应头里面再把原数据发回给浏览器。该方法通常只针对文本数据，对于图片视频等没什么作用。

   2. 分块传输

         · 响应报文：Transfer-Encoding: chunked来表示报文里的body部分不是一次性发过来的，而是分成了许多的块逐个发送。这个参数
         
         跟Content-Length是互斥的
         
         · 流式传输：例如由数据库动态生成的表单页面，这种情况下body数据的长度是未知的，无法在头字段"Content-Length"里给出确切
         
         的长度，所以必须用分块传输
         
         · 分块传输的编码规则：包含两个部分长度头和数据块

<div align=center>
<img src="https://static001.geekbang.org/resource/image/25/10/25e7b09cf8cb4eaebba42b4598192410.png"/>
</div>
3.范围请求

​     ·概念：允许客户端在请求头里使用专用字段来表示只获取文件的一部分。

​     ·客户端：请求头用Ranges来表示范围请求，格式是"bytes=x-y"，这里的x和y表示字节为单位的数据范围，从0开始计数，计数方式跟数组语法一样。

​     ·服务器：范围请求对于服务器来说不是必要的。因此服务器要是支持，必须通过发送“Accept-Ranges: bytes”明确告知客户端。服务器在收到Ranges字段之后做了以下几件事

​                           -先检查范围是否合法，请求的范围是否超过了文件大小

​                           -范围检查合法之后，根据Ranges对应的范围读取文件片段，状态码此时采用“206 Partial Content”

​                           -服务器添加响应头字段Content-Range,该字段告知客户端片段的实际偏移量和资源总大小，格式是“bytes x-y/lenget”

​                           -把片段用tcp发送回给客户端

4.多段数据

<div align=center>
<img src="https://static001.geekbang.org/resource/image/ff/37/fffa3a65e367c496428f3c0c4dac8a37.png"/>
</div>

范围请求一次只获取一个字段，在range头里使用多个"x-y",一次性可以获取多个字段



## 2⃣️HTTP的连接管理

1.短链接(short-lived connections)

   通过3次握手(**3个数据包，一个rtt**)之后建立了连接，然后进行了一次请求响应(**4个包，最多两次rtt**)，就通过四次挥手（4个包，两次rtt）断开链接。在这个过程里面，建立连接和关闭连接占用三分之二的时间，因此传输效率特别低下。

2.长连接(persistent connections、keep alive、connection reuse)

   采用"成本均摊"的思路，将多个请求响应只用一次连接和关闭过程。一次长连接发送的请求越多，分母就越大，利用率也越高

   缺点：tcp连接长时间不关闭，服务器必须要在内存中保存其状态，占用了服务器的资源。因此长连接也需要在一定的时间后关闭。

   缺点应对策略：对于客户端通过在请求头里添加"Connection: close"显式的告知服务器要断开连接。

​                              对于服务端，可通过设置**超时时间**或者**单个长连接最大请求次数**来主动断开连接。

​              

3.连接相关的头字段

   在http/1.1中的连接都默认启用长连接，不需要用什么特殊的头字段指定，只要向服务器发送了第一次的请求，后续的请求都会重复利用第一次打开的tcp连接，在这个连接上收发数据。

   请求头明确要求使用长连接机制：字段：Connection ; 值: Keep-alive

   服务器支持长连接响应头：字段：Connection ; 值: Keep-alive

4.队头阻塞(Head-of-line blocking)

 由http的“请求-应答”模型导致的。因为http规定的报文必须是"一发一收"，因此会形成一个先进先出的**串型队列**。队列里最前面的请求被优先处理，因此若队首的请求因处理的太慢耽误了时间，那么队列后面的所有请求也不得不跟着一起等待，结果就是其他的请求也一次承担了不应有的时间成本。这也是先进先出数据结构的缺陷，在早期的操作系统进程调度也是采用这种先进先出，导致很多后面进来的任务一直卡住直到给饿死了。

  应对策略：在http里通过**并发连接(concurrent connections)**,也就是对一个域名发起多个长连接，用分片数量来解决质量问题。如果浏览器限制了并发数量，可以通过"域名分片"来解决，即多个host都可以映射到一个主host。



## 3⃣️HTTP的重定向和跳转

1.重定向的响应头

   字段：Location     值：要跳转的目录

2.重定向状态码

   301:永久重定向(Moved Permanently)，原来的uri过时了。

   302:临时重定向(Moved Temporarily)，原uri处于临时维护状态，新的uri是临时使用

   303:类似302，但请求方法规定必须用GET,避免使用post/put重复操作

   307:类似302，但重定向后请求里的方法和实体不允许变动，含义比302更明确

   308:类似301，但重定向后请求里的方法和实体不允许变动。

3.应用场景

   (1)资源不可用：域名变更、服务器变更、网站维护、版本更新都会导致原uri指向的资源无法访问，为了避免出现404，就需要使用重定向跳转到新的uri继续为网民提供服务

   (2)避免重复：让多个网址都跳转到一个uri,增加访问入口的同时还不会增加额外的工作量。例如申请多个名称类似的域名，然后把它们重定向到主战上。

4.301使用场景

   启用了新域名、服务器切换到了新机房、网站目录层次重构。导致原先的uri不能用了，必须用301“永久重定向”。

5.302使用场景

  一种是由于系统维护，把网站重定向到一个通知页面，告诉用户过一会再来访问。

  另一种是“服务降级”，例如在流量高峰把一些不重要的功能入口暂时关闭，保证核心服务能够正常运行。

6.重定向的缺点

  重定向应当适度使用，不能滥用。

  (1)性能损耗：重定向会比正常访问多一次“请求应答”。假如跳转到站外，那么就不能使用长连接，此时还需要一次建立连接的过程。

  (2)循环跳转：如果重定向的策略设置欠考虑，可能会出现重定向之后跳回原页面导致一个闭环。所以http协议跪了了，浏览器需要有检测"循环跳转"的能力，在发现这种情况的时候应该停止发送请求并给出错误提示，如*重定向的次数过多*。

​    

## 4⃣️HTTP的cookie机制

  1.作用

​     客户端记录着只有服务器才能理解的数据，服务器看到cookie，就能够认出客户端是谁。

  2.cookie工作过程

   请求头字段Cookie

   响应头字段Set-Cookie

   浏览器第一次访问服务器的时候，服务器会创建一个独特的身份标识数据。格式是“key=value”,然后放进Set-Cookie字段里，随着响应报文一同发给浏览器。浏览器收到之后就会将cookie保存下来，下次请求的时候就会把这个值放进Cookie字段里发给服务器。

 3.cookie的属性

  Cookie记录着用户的关键识别信息，因此需要在key=value外再用一些手段来保护，防止外泄或窃取，这些手段就是cookie的属性。

  (1)cookie的生存周期

​     也就是cookie的有效期，让它只能在一段时间内可用，一旦超过这个有效期浏览器就认为cookie失效，在存储里会删除也不会发送给服务器。

​     Expires: “过期时间”。用的是绝对时间，可以理解为deadline。

​     Max-Age: "相对时间"，单位是秒。浏览器用收到的报文的时间点+  Max-Age，就可以得到失效的绝对时间。

​    以上两者可以同时出现，两者的实效时间可以不一致，浏览器会优先采用Max-Age计算失效时间。

 (2)作用域

   "Domain"和"Path"指定了cookie所属的域名和路径。

 (3)安全性

  "HttpOnly": 告诉浏览器，此cookie只能通过浏览器http协议运输，禁止其他方式访问。

  "SameSite"：可以防范“跨站请求伪造”攻击。

​                          值设置成Strict可以严格限定Cookie不能随着跳转链接跨站发送。

​                          值设置成Lax，规定稍微宽松，允许GET/HEAD等安全方法，但禁止POST跨站发送。

  "Secure": 表示Cookie在传输过程中需要用https协议加密传输，禁止发送明文。

4.cookie的应用

  (1)身份识别

​     保存用户的登录信息，实现会话事务。用账号密码登陆成功后，服务器会返回一个id标签给浏览器，之后浏览器访问网站的任一页面都会把身份cookie返回给服务器，这时候服务器也能够记录浏览记录等。

  (2)广告跟踪

   网页的广告图片等会给浏览器返回cookie标签，这些cookie不是由访问的主站存储的。当浏览器随带着这些cookie，那么在别的网站也可识别出来实现精准广告推送。

## 5⃣️HTTP的缓存控制

1.背景

   http传输的每一个环节基本都会有缓存，目的是为了避免多次请求-应答的通信成本，节约网络带宽，也可以加快响应速度

2.服务器的缓存控制

   (1)http的缓存流程

​     a.浏览器发现缓存无数据，于是发送请求，向服务器获取资源

​     b.服务器响应请求，返回资源，同时标记资源的有效期

​     c.浏览器缓存资源，等待下次重用。

   (2)服务器标记资源有效期使用的头字段

​    	Cache-Control: max-age=30 

​        通过该字段告诉浏览器只能缓存30秒，之后就算是过期了不能用。该字段的时间计算起点是响应报文创建时刻，即报文离开服务器的时刻，而不是客户端收到报文的时刻，也就是说该字段的时间包含了在链路传输过程中所有节点停留的时间。

​        响应报文更精确指示浏览器该如何使用缓存：

​         no-store：不允许使用缓存，用于变化非常频繁的数据，例如秒杀页面

​         no-cache：可以使用缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本

​         must-revalidate：缓存不过期可以继续使用，但过期了如果还想用就必须去服务器验证。

![image-20210513213943321](/Users/biqiouyang/Desktop/临时文件夹/images/image-20210513213943321.png)