http协议

===================================  

###多行文本框

​		1⃣️全称：Hyper Text Transfer Protocol（超文本传输协议）

​		2⃣️HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。

​		3⃣️http基于tcp协议，https基于TLS或SSL协议层之上；http端口号为80，https端口号为443

​		4⃣️http的响应方式：响应方式单一，遵循client------->server 单一的方向进行请求，server------->client返回请求

​		5⃣️https:全称Hypertext Transfer Protocol over Secure Socket Layer。是以安全为目标的http通道，实现的方式为在http下加入ssl层。端口号443

​		 有两种基本的加解密算法类型：

​		1）对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；

​		2）非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。
​				流程：

	 									  --------                        --------
					           | client |                      | server |
	                    --------                        --------
	                                请求https连接         
	                            -------------------->>  
	                                返回证书公钥
	                            <<-------------------
	                          client产生随机的的(对称)密钥
	                          client使用公钥对对称密钥加密   
	
	                                发送加密后的对称密钥         
	                            -------------------->>
	                                
	                            <<-------------------
	                            
	                                通过对称密钥加密密闻通信
	                            -------------------->>
	                            <<------------------- 

		6⃣️Flags值说明：
		    FIN: "finished"简写。表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。
		    SYN: "Synchronisation"简写。表示三次握手建立连接的第一步，在建立连接时发送者发送的第一个包中设置flag值为SYN。
		    RST: "reset"简写。重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者发送包发送到一个不是期望的                  目的主机时，接收端发送reset 重置连接标志的包。
		    PSH: "push"简写。通知接收端处理接收的报文，而不是将报文缓存到buffer中。
		    ACK: "Acknowledgment"简写。表示包已经被成功接收。
		    URG: "urgent"简写。通知接收端处理在处理其他包前优先处理接收到的紧急报文（urgent packets）。详见RFC6093。
		    ECE: "ECN-Echo"简写。ECN表示Explicit Congestion Notification。表示TCP peer有ECN能力。详见RFC3168。
		    CWR: "Congestion Window Reduced"简写。发送者在接收到一个带有ECE flag包时，将会使用CWR flag。 详见RFC3168。
		    NS: "nonce sum"简写。该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。详见 RFC 3540。 

    
         6⃣️Flags值说明：
    		    FIN: "finished"简写。表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。
    		    SYN: "Synchronisation"简写。表示三次握手建立连接的第一步，在建立连接时发送者发送的第一个包中设置flag值为SYN。
    		    RST: "reset"简写。重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者发送包发送到一个不是期望的                  目的主机时，接收端发送reset 重置连接标志的包。
    		    PSH: "push"简写。通知接收端处理接收的报文，而不是将报文缓存到buffer中。
    		    ACK: "Acknowledgment"简写。表示包已经被成功接收。
    		    URG: "urgent"简写。通知接收端处理在处理其他包前优先处理接收到的紧急报文（urgent packets）。详见RFC6093。
    		    ECE: "ECN-Echo"简写。ECN表示Explicit Congestion Notification。表示TCP peer有ECN能力。详见RFC3168。
    		    CWR: "Congestion Window Reduced"简写。发送者在接收到一个带有ECE flag包时，将会使用CWR flag。 详见RFC3168。
    		    NS: "nonce sum"简写。该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。详见 RFC 3540。 
         7⃣️client和server的交互过程   
    			   --------                        --------
    			  | client |                      | server |
                   --------                        --------
                                发出连接请求(此为TCP三次握手第一步，此时标志位为SYN，seq:X (x=0))         
                            -------------------->>  
                                server回应了client的请求，并要求确认(此为三次握手的第二步；此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）)
                            <<-------------------  
                                client回应了server的确认(此为三次握手的第三步，为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。)         
                            -------------------->>
                                
                    --------连接成功以下开始传输数据---------
                                 
                           client发送一个页面http请求   [server确认]
                            -------------------->>
                                   发送数据
              [client确认]  <<--------------------
                           client发送一个图片http请求   [server确认]
                            -------------------->>
                                  发送图片数据
               [client确认] <<--------------------    
    
        8⃣️http报文
              一个完整的http报文有起始行、头部、空行、实体组成。请求报文和响应报文只有其实行字段不太一样，其他组成都差不多
              结构如下：   
                           ----------起始行----------
                           ----------头部------------由很多行组成
                           ----------空行------------CRLF
                           ----------实体------------post、put等方法需要提交一些数据到服务端
    
              起始行：有两种，一种是请求报文的请求行，另一种是响应报文的响应行。
                     请求行：1.请求方法： 是一个动词，如get/post,表示对资源的操作
                            2.请求目标：通常是一个url，标记了请求方法要操作的资源。
                            3.版本号：表示报文使用的http协议版本。
                            这三个部分用空格隔开，最后用crlf来换行
    
                     响应行：1.版本号：同上
                            2.状态码：一个三位数，用代码的形式表示处理的结果，比如200是成功，500是服务器错误
                            3.原因：作为数字状态码的补充，是更详细的解释文字，帮助理解原因
                            格式同上
    
      9⃣️请求方法
             背景：http协议最终的目的是为了操作url定位的服务器资源，因此在协议里面必须有某种“动作的指示”，告诉操作这些资源的方式。
             方法：1.get：获取资源，可以理解为读取或者下载数据
                  2.head：类似get，但只获取资源的元信息
                  3.post：向资源提交数据，相当于写入或上传数据
                  4.put：类似post
                  5.delete：删除资源
                  6.connect：建立特殊的连接隧道
                  7.options：列出可对资源实行的方法
                  8.trace：追踪请求-响应的传输路径
             扩展方法：http协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。
             安全与幂等：
                  get和head方法只读操作所以是安全的，其他方法都涉及到服务器的增删改，所以是“不安全的”
                  幂等：多次执行相同的操作，结果都是相同的。post是"新增或提交数据"，多次提交数据会创建多个资源，所以不是幂等的。put是"替换或更新数据"，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。
    
      🔟body实体
             1. 数据类型与编码
                    假如http没有告知数据类型的功能，服务器把“一大坨”数据发给浏览器，浏览器看到的将是一个黑盒子。因此需要注明数据的类型
                    常见的类型有： a. text文本格式
                                 b. image
                                 c. audio/video
                                 d. application 数据格式不固定可能是文本也可能是二进制，必须由上层应用程序来解释
                    还需要告诉数据是什么编码格式，方便对方解压：a. gzip
                                                          b. deflate
                                                          c. br 新优化的算法
    
                数据类型使用的头字段：
                      客户端用Accept头告诉服务器希望接收什么样的数据，而服务器用Content头告诉客户端实际发送了什么样的数据。
                      对于编码字段，是可以省略的。如果没有Accept-Encoding字段，就表示不支持接收压缩数据；如果没有Content-Encoding字段，就表示发送数据没有被压缩。
    
             2.语言类型与编码
                    通过区分语言类型来使浏览器显示不同的语言。

http协议进阶：
       1⃣️http是如何传输大文件的？
               1. 数据压缩 
                     浏览器向服务器发送请求的时候通常都会通过““Accept-Encoding””字段告知自己支持那种压缩格式，例如gzip、deflate、br等。服务器会选择一种压缩算法，放进Content-Encoding响应头里面再把原数据发回给浏览器
                     该方法通常只针对文本数据，对于图片视频等没什么作用

               2.分块传输
                     响应报文：Transfer-Encoding: chunked来表示报文里的body部分不是一次性发过来的，而是分成了许多的块逐个发送。这个参数跟Content-Length是互斥的
                     流式传输：例如由数据库动态生成的表单页面，这种情况下body数据的长度是未知的，无法在头字段"Content-Length"里给出确切的长度，所以必须用分块传输
                     分块传输的编码规则：包含两个部分长度头和数据块

<div align=center>
<img src="https://static001.geekbang.org/resource/image/25/10/25e7b09cf8cb4eaebba42b4598192410.png"/>
</div>
               3.范围请求



### client和server的交互过程

	         --------                        -------
	        | client |                      | server |
	         --------                        --------
	                     发出连接请求(此为TCP三次握手第一步，此时标志位为SYN，seq:X (x=0))         
	                        -------------------->>  
	           server回应了client的请求，并要求确认(此为三次握手的第二步；此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）)
	                        <<-------------------  
	
	                      client回应了server的确认(此为三次握手的第三步，为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。)         
	                        -------------------->>
	                            
	                --------连接成功以下开始传输数据---------
	                             
	                       client发送一个页面http请求   [server确认]
	                        -------------------->>
	                               发送数据
	          [client确认]  <<--------------------
	                       client发送一个图片http请求   [server确认]
	                        -------------------->>
	                              发送图片数据
	           [client确认] <<--------------------    

