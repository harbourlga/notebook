KAFKA 消息系统

1⃣️ 概述：KAFKA最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者基于zookeeper协调的分布式日志系统（也可以当做MQ系统）。常见可以用于web/nginx日志、访问日志，消息服务等等

   主要应用场景：日志收集系统和消息系统
   主要设计目标：以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。
               高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。
               支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。
               同时支持离线数据处理和实时数据处理。
               Scale out:支持在线水平扩展

   消息系统的介绍
	   一个消息系统负责将数据从一个应用传递到另一个应用，应用只需关注数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：点对点传递模式、发布-订阅模式。大部分消息系统选用发布-订阅模式。Kafka就是一种发布-订阅模式。
	      1. 点对点传递模式
	          概述：在点对点的模式中，消息会持久化到一个队列中，此时会有多个或一个消费者通过这个队列拿数据。生产者产生一个消息塞到消息队列里面，无论有多少个消费者最终只能有一个消费者拿到这个消息。某一消费者拿到消息后，这条数据就从消息队列里面删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。
	         
	          案例：一个无状态的计算任务，为了提高并发能力和计算速度横向扩展至多个节点，每个节点的计算逻辑都是一样的。后台的某个请求需要进入该计算任务进行一次处理，只需要塞到消息队列里面，让这多个计算节点去抢，随便那个抢到都可以，执行完了把结果发回给后台。

	          总结： 生产者发送一条消息到queue，只有一个消费者能收到。
	      
	      2. 发布订阅模式
	          概述：在发布-订阅系统中，消息被持久化到一个topic中去。与点对点的模式不同，消费者可以订阅一个或多个topic，消费者可以消费该topic中的所有数据，并且topic中的同一条数据会被多个consume消费，数据被消费之后不会立马删除。在发布订阅模式中，消息的生产者称为发布者，消费者称为订阅者
	          
	          总结：发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。
	          
	          案例：多个客户端(订阅者)同时订阅了某新闻可能是采用轮询的方式定时监听topic，当发布者将新闻塞入到topic中去的时候，多个订阅者开始接收这个新闻。

2⃣️优点：1. 解偶： 生产者和消费者两边程序的处理过程互不干扰，只要保证接口一致就好了
        2. 冗余（副本）： 消息队列把数据进行了持久化，直到消费者完全处理完明确要删除。规避了数据丢失的风险
        3. 扩展性：由于生产者和消费者两边解偶， 不需要改变代码调节参数等。只需要消费者的处理任务节点进行扩容即可。
        4.灵活性&峰值处理能力：使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。即让topic中的消息乖乖等待直到被采用，按照消费者的节奏来走。
        5.可恢复性：系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
        6.顺序保证：一个partition内的顺序是能够保证的
        7.缓冲：在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。
        8.异步通信：
          很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。

3⃣️术语解释：
       1. broker: KAFKA的集群包含多个节点每个节点即为一个broker。
                  broker存储着topic的数据。topic内部又分为多个partition。
                   partition与broker的对应关系如下： a. partition与broker数量相等，则一对一存储
                                                  b. broker数量比partition多，则分配partition数量大小的broker一对一存储
                                                  c. broker数量比partition少，则某些broker会存储多个partiotion。在实际生产环境中应避免这种情况，因为不同partition之间顺序不一致，另外容易引起集群数据不均衡

       2. topic(类别，主题)：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。物理上不同topic的数据分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处。

       3. Partition
             topic中的数据分割为一个或多个partition。每个topic至少有一个partition，每个partition中的数据使用多个segment文件存储。单个partition内部的顺序是有序的，不同的partition之间是无序的。如果一个topic分成多个partition，则不能保证数据处理的顺序，因此在严格保证消息的消费顺序的场景下，需要将partition数目设为1。

       4. Producer(生产者)：数据的发布者，该角色负责将消息发布到kafka的topic中。broker接收到生产者发送的消息之后，会将该消息追加到当前用于追加数据的segment文件中去。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。

       5. Consumer： 消费者可以从broker中读取多个topic的数据。

       6. Consumer Group： consumer所属的的tank。

       7. Leader: 每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。

       8.Follower: foller跟随leader，leader负责写任务。leader会将数据变化广播到所有foller中去。leader和foller之间关系遵循zookeeper协议



4⃣️kafka的架构： 

          producer: 有好几个producer，可能是前端web产生的数据、服务器日志、cpu、内存等。
          broker：可以水平扩展，broker数量越多吞吐量越大
          consumer: 
